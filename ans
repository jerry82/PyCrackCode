12.1. How to store stock price:

open, high, low, close = 5000 x 4 = 20,000
1000 daily users : 
Solutions:
use Text file: (hard to modified)
use XML file: (easy to read, moderate to modify if data is big)
use Database: (easy to read, write, load balance, extensible)


12.2. represent big graph Facebook or Linkedin

Use graph data structure
represent each person as a class 
graph node store only person id

public class Person {
	public String Name { get; set; }
	public String LastName { get; set; }
	public String Email { get; set; }
	public String Id { get; set; }
	public List<string> FriendIds { get; set; }
}

public class Node {
	public string Id { get; set; }
	public string personId { get; set }
	public List<string> FIds { get; set; }
	public string MachineId { get; set; }


}

AppLogic.getFriends(visited, curNode);

public class AppLogic {
	//...

	public Person getPerson(Node node) {
		string machineId = noe.MachineId;

		return Server.getPerson(machineId, node.Id);
	}

	//...
}

public class Program {
	
	private Graph _graph = null
	public Program(Graph graph) {
		_graph = graph;
	}

	//implement BFS
	public void BuildPath(string person1Id, string person2Id) {

		TraceNode node1Id = DB.getNodeId(person1Id);
		TraceNode node2Id = DB.getNodeId(person2Id);

		//BFS to connect node
		Dictionary<TraceNode, int> visited = new Dictionary<TraceNode, int>()		
		Queue<TraceNode> myQ = new Queue<TraceNode>();
		myQ.Enqueue(node1Id);

		while(myQ.Count > 0) {
			TraceNode curNode = myQ.Dequeue();
			visited.Add(curNode, 1);

			//make sure the friend not in visted list
			List<TraceNode> friends = AppLogic.getFriends(visited, curNode);
			foreach (TraceNode friend in friends) { 
				if (friend == node2Id) {
					//found
					break;
				}
		
				//for trace back
				friend.Prev = curNode
				myQ.Enqueue(friend)
			}
		}

		//DFS
		Stack<TraceNode> myS = new Stack<TraceNode>();

		myS.Push(node1Id);

		while (myS.Count > 0) {
			TraceNode cur = myS.Peek();

			visited.Add(cur);

			//friend not visited and friend has some similiar geographical location with node2Id
			TraceNode friend = AppLogic.getOneFriend(visited, cur);

			if (friend != null) {

				if (friend == node2Id) {
					//found
					break;
				}
				//for backtracking
				friend.prev = curNode
				myS.Push(friend);
				visited.Add(friend, 1);
			}
			else {
				myS.Pop();
			}


		}
		
	}
}

12.3 Stack vs Heap 
Stack: 
	. code, value type, manage its own memory, clear the unused slot
	. not garbage collectible
	. extremely fast, access from processor by stack pointer, pointer move updown to 
	assign or clear the memory

Heap: 
	. reference type, pointer, need GC to manage the space

12.4 Hadoop and Map Reduce
Opensource software that allow concurrently map the program to distributed node, execute
program on each node paralelly and combine the result to return result to the request(Reduce) 
HDFS: Hadoop Distributed File System

12.5 Memory Paging
Control how the Virtual Memory are shared. When lack of RAM, CPU use storage as disk to act as RAM -> 
Page file.

12.6 Distributed Cached
Cache = normally memory database design for quick retrieval just like NoSQL
Cache distributed in each nodes (copies will be store in different nodes)

12.7 How browser works:
Enter address into browser, the B will establish a Http connection to the server, download HTML. 
Then it builds a DOM object (document object model as a tree), then download css, script, images
Javascript can change DOM on the fly. 

12.8 Consumer and Producer:
Semaphore is a new type (~ interger only allow 2 operations: wait(s) and signal(s))
. wait(s) : wait for s to  be > 0, then s = s - 1 and return (atomic operation)
. sign(s) : simply increment s = s + 1

(binary semaphore) 0 or 1 (use as lock)

Semaphore introduces deadlock:
To solve dead lock , assign number to resource, for all processes, try to access the resource with
lower number if cannot then wait









